#!/usr/bin/python3
#	pdfminify - Tool to minify PDF files.
#	Copyright (C) 2016-2016 Johannes Bauer
#
#	This file is part of pdfminify.
#
#	pdfminify is free software; you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation; this program is ONLY licensed under
#	version 3 of the License, later versions are explicitly excluded.
#
#	pdfminify is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.
#
#	You should have received a copy of the GNU General Public License
#	along with pdfminify; if not, write to the Free Software
#	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#	Johannes Bauer <JohannesBauer@gmx.de>
#

import sys
import os
import logging
import argparse
import llpdf
from FriendlyArgumentParser import FriendlyArgumentParser
from FilesizeFormatter import FilesizeFormatter

def _cropbox(text):
	text = text.split(",")
	if len(text) != 4:
		raise argparse.ArgumentTypeError("expected four comma-separated values, but %d given." % (len(text)))
	return [ float(value) for value in text ]

def _intrange(minvalue, maxvalue):
	def convert(text):
		value = int(text)
		if (minvalue is not None) and (value < minvalue):
			raise argparse.ArgumentTypeError("value must be at least %d." % (minvalue))
		if (maxvalue is not None) and (value > maxvalue):
			raise argparse.ArgumentTypeError("value may be at most %d." % (maxvalue))
		return value
	return convert

parser = FriendlyArgumentParser()
parser.add_argument("--target-dpi", metavar = "dpi", type = int, default = 150, help = "Default resoulution to which images will be resampled at. Defaults to %(default)s dots per inch (dpi).")
parser.add_argument("--jpeg-images", action = "store_true", help = "Convert images to JPEG format. This means that lossy compression is used that however often yields a much higher compression ratio.")
parser.add_argument("--jpeg-quality", metavar = "percent", type = _intrange(0, 100), default = 85, help = "When converting images to JPEG format, the parameter gives the compression quality. It is an integer from 0-100 (higher is better, but creates also larger output files).")

parser.add_argument("--cropbox", metavar = "box", type = _cropbox, help = "Crop pages by additionally adding a /CropBox to all pages of the PDF file. Pages will be cropped at offset (x, y) to a width (w, h). Must be given in the format x,y,w,h. The unit in which offset, width and height are given can be specified using the --unit parameter.")
parser.add_argument("--unit", choices = llpdf.Measurements.list_units(), default = "native", help = "Specify the unit of measurement that is used for input and output. Can be any of %(choices)s, defaults to %(default)s. One native PDF unit equals 1/72th of an inch.")

parser.add_argument("--one-bit-alpha", action = "store_true", help = "Force all alpha channels in images to use a color depth of one bit. This will make transparent images have rougher edges, but saves additional space.")
parser.add_argument("--remove-alpha", action = "store_true", help = "Entirely remove the alpha channel (i.e., transparency) of all images. The color which with transparent areas are replaced with can be specified using the --background-color command line option.")
parser.add_argument("--background-color", metavar = "color", type = str, default = "white", help = "When removing alpha channels, specifies the color that should be used as background. Defaults to %(default)s. Hexadecimal values can be specified as well in the format '#rrggbb'.")

parser.add_argument("--saveimgdir", metavar = "path", type = str, help = "When specified, save all handled images as individual files into the specified directory. Useful for image extraction from a PDF as well as debugging.")
parser.add_argument("--raw-output", action = "store_true", help = "When saving images externally, save them in exactly the format in which they're also present inside the PDF. Note that this will produce raw image files in some cases which won't have any header (but just contain pixel data). Less useful for image extraction, but can make sense for debugging.")
parser.add_argument("--pretty-pdf", action = "store_true", help = "Write pretty PDF files, i.e., format all dictionaries so they're well-readable regarding indentation. Increases required file size a tiny bit and increases generation time of the PDF a little, but produces easily debuggable PDFs.")

parser.add_argument("--no-xref-stream", action = "store_true", help = "Do not write the XRef table as a XRef stream, but instead write a classical PDF XRef table and trailer. This will increase the file size a bit, but might improve compatibility with old PDF readers (XRef streams are supported only starting with PDF 1.5). XRef-streams are a prerequisite to object stream compression, so if XRef-streams are disabled, so will also be object streams (e.g, --no-object-streams is implied).")
parser.add_argument("--no-object-streams", action = "store_true", help = "Do not compress objects into object-streams. Object stream compression is introduced with PDF 1.5 and means that multiple simple objects (without any stream data) are concatenated together and compressed together into one large stream object.")

parser.add_argument("--dump-xref-table", action = "store_true", help = "Dump out the XRef table that was read from the input PDF file. Mainly useful for debugging.")
parser.add_argument("--no-optimization", action = "store_true", help = "Do not perform any optimization or filters on the source PDF whatsoever, just read it in and write it back out. This is useful to debug the PDF reader/writer facilities without introducing other sources of malformed PDF generation.")
parser.add_argument("-v", "--verbose", action = "count", default = 0, help = "Show verbose messages during conversation. Can be specified multiple times to increase log level.")
parser.add_argument("infile", metavar = "pdf_in", type = str, help = "Input PDF file.")
parser.add_argument("outfile", metavar = "pdf_out", type = str, help = "Output PDF file.")
args = parser.parse_args(sys.argv[1:])

llpdf.configure_logging(args.verbose)
llpdf.Measurements.set_default_unit(args.unit)

pdf_filter_classes = [
	llpdf.filters.RemoveDuplicateImageOptimization,
	llpdf.filters.FlattenImageOptimization,
	llpdf.filters.DownscaleImageOptimization,
	llpdf.filters.AddCropBoxFilter,
	llpdf.filters.ExplicitLengthFilter,
	llpdf.filters.DeleteOrphanedObjectsFilter,
]

log = logging.getLogger("llpdf")

fsf = FilesizeFormatter()
old_size = os.stat(args.infile).st_size
with open(args.infile, "rb") as infile, open(args.outfile, "wb") as outfile:
	pdf = llpdf.PDFFile(infile)

	if args.dump_xref_table:
		pdf.xref_table.dump()

	if not args.no_optimization:
		for pdf_filter_class in pdf_filter_classes:
			log.debug("Running filter: %s", pdf_filter_class.__name__)
			pdf_filter = pdf_filter_class(pdf, args)
			pdf_filter.run()
			if args.verbose:
				log.debug("%s saved %s." % (pdf_filter_class.__name__, fsf(pdf_filter.bytes_saved)))

	writer = llpdf.PDFWriter(pdf, outfile, pretty = args.pretty_pdf, use_xref_stream = not args.no_xref_stream, use_object_streams = not args.no_object_streams)
	writer.write()
new_size = os.stat(args.outfile).st_size
if args.verbose:
	percent = 100 * new_size / old_size
	saved = old_size - new_size

	details = [ ]
	details.append("%.0f%% of original" % (percent))
	if saved > 0:
		details.append("%s saved" % (fsf(saved)))
	else:
		details.append("%s growth" % (fsf(-saved)))

	if saved > 0:
		details.append("ratio %.1f : 1" % (old_size / new_size))
	else:
		details.append("ratio 1 : %.1f" % (new_size / old_size))

	log.info("File size %s -> %s (%s)" % (fsf(old_size), fsf(new_size), ", ".join(details)))

